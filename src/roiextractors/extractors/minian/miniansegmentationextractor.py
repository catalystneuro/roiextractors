"""A SegmentationExtractor for Minian.

Classes
-------
MinianSegmentationExtractor
    A class for extracting segmentation from Minian output.
"""

import warnings
from pathlib import Path

import numpy as np
import pandas as pd
import zarr

from ...extraction_tools import FloatType, PathType
from ...segmentationextractor import (
    SegmentationExtractor,
    _ROIMasks,
    _RoiResponse,
)


class MinianSegmentationExtractor(SegmentationExtractor):
    """A SegmentationExtractor for Minian.

    This class inherits from the SegmentationExtractor class, having all
    its functionality specifically applied to the dataset output from
    the 'Minian' ROI segmentation method.

    Users can extract key information such as ROI traces, image masks,
    and timestamps from the output of the Minian pipeline
    (https://minian.readthedocs.io/en/stable/pipeline/notebook_5.html).
    More specifically, it reads the .zarr output files generated by Minian:
    A.zarr: Spatial footprints of cells. Should have dimensions ("unit_id", "height", "width"). --> image_masks
    C.zarr: Temporal components of cells. Should have dimensions "frame" and "unit_id". --> roi_response_denoised
    b.zarr: Spatial footprint of background. Should have dimensions ("height", "width"). --> background_image_masks
    f.zarr: Temporal dynamic of background. Should have dimension "frame". --> roi_response_neuropil
    b0.zarr: Baseline fluorescence for each cell. Should have dimensions ("frame", "unit_id") and same shape as C --> roi_response_baseline
    c0.zarr: Initial calcium decay, in theory triggered by calcium events happened before the recording starts. Should have dimensions ("frame", "unit_id") and same shape as C
    S.zarr: Deconvolved spikes for each cell. Should have dimensions ("frame", "unit_id") and same shape as C --> roi_response_deconvolved
    max_proj.zarr: the maximum projection --> summary_image

    Key features:
    - Extracts fluorescence traces (denoised, baseline, neuropil, deconvolved) for each ROI.
    - Retrieves ROI masks and background components.
    - Provides access to timestamps corresponding to calcium traces.
    - Retrieves maximum projection image.

    """

    extractor_name = "MinianSegmentation"

    def __init__(
        self,
        folder_path: PathType,
        sampling_frequency: float | None = None,
        timestamps_path: PathType | None = None,
    ):
        """Initialize a MinianSegmentationExtractor instance.

        Parameters
        ----------
        folder_path: str or Path
            The location of the folder containing minian .zarr output.
        sampling_frequency: float, optional
            The sampling frequency in Hz. If not provided, will attempt to derive from timeStamps.csv.
        timestamps_path: str or Path, optional
            Path to the timeStamps.csv file. If not provided, assumes default location at folder_path/timeStamps.csv.
        """
        SegmentationExtractor.__init__(self)
        self.folder_path = Path(folder_path)
        self._sampling_frequency = sampling_frequency
        self._timestamps_path = (
            Path(timestamps_path) if timestamps_path is not None else self.folder_path / "timeStamps.csv"
        )

        # Read cell masks
        cell_image_masks = self._read_roi_image_mask_from_zarr()
        if cell_image_masks is not None:
            cell_ids = list(range(cell_image_masks.shape[2]))
        else:
            cell_ids = []
        self._roi_ids = list(cell_ids)

        denoised_traces = self._read_trace_from_zarr_field(field="C")
        if denoised_traces is not None:
            self._roi_responses.append(_RoiResponse("denoised", denoised_traces, list(self._roi_ids)))

        baseline_traces = self._read_trace_from_zarr_field(field="b0")
        if baseline_traces is not None:
            self._roi_responses.append(_RoiResponse("baseline", baseline_traces, list(self._roi_ids)))

        background_trace = self._read_trace_from_zarr_field(field="f")
        if background_trace is not None:
            if background_trace.shape[1] == len(self._roi_ids):
                background_ids = list(self._roi_ids)
            else:
                background_ids = [f"background-{idx}" for idx in range(background_trace.shape[1])]
            self._roi_responses.append(_RoiResponse("background", background_trace, background_ids))

        deconvolved_traces = self._read_trace_from_zarr_field(field="S")
        if deconvolved_traces is not None:
            self._roi_responses.append(_RoiResponse("deconvolved", deconvolved_traces, list(self._roi_ids)))
        max_proj_data = self._read_zarr_group("/max_proj.zarr/max_proj")
        if max_proj_data is not None:
            self._summary_images["maximum_projection"] = np.array(max_proj_data)

        # Create ROI representations combining cell and background masks
        background_image_masks = self._read_background_image_mask_from_zarr()
        self._roi_masks = self._create_roi_masks(cell_image_masks, background_image_masks, cell_ids, background_trace)
        # Check for spatial-temporal component mismatches
        has_temporal_responses = any(
            response.response_type in {"denoised", "deconvolved", "baseline"} for response in self._roi_responses
        )
        if cell_image_masks is not None and not has_temporal_responses:
            raise ValueError(
                "Spatial components (A.zarr) are available but no temporal components (C.zarr, S.zarr, b0.zarr) are associated. "
                "This means ROI masks exist but without any corresponding fluorescence traces."
            )

        has_background_response = any(response.response_type == "background" for response in self._roi_responses)
        if background_image_masks is not None and not has_background_response:
            raise ValueError(
                "Background spatial components (b.zarr) are available but no background temporal component (f.zarr) is associated. "
                "This means background masks exist but without corresponding temporal dynamics."
            )

        # Validate that either sampling frequency or valid timestamps are available
        if self._sampling_frequency is None:
            if not self._timestamps_path.exists():
                raise ValueError(
                    f"No sampling frequency provided and timestamps file not found at {self._timestamps_path}. "
                    "Please provide either a sampling_frequency parameter or ensure a valid timeStamps.csv file exists."
                )
            else:
                try:
                    self.get_native_timestamps()
                except Exception as e:
                    raise ValueError(
                        f"Error reading timestamps from {self._timestamps_path}: {e}. "
                        "Please provide a valid timeStamps.csv file or a sampling_frequency parameter."
                    )

    def _create_roi_masks(
        self, cell_image_masks, background_image_masks, cell_ids, background_trace
    ) -> _ROIMasks | None:
        """Create ROI representations combining cell and background masks.

        Minian is 2D only - no 3D/volumetric support needed.

        Parameters
        ----------
        cell_image_masks : np.ndarray or None
            Cell image masks with shape (height, width, n_cells).
        background_image_masks : np.ndarray or None
            Background image masks with shape (height, width, n_backgrounds) or (height, width).
        cell_ids : list
            List of cell IDs.
        background_trace : _RoiResponse or None
            Background trace response to determine background IDs.

        Returns
        -------
        _ROIMasks or None
            Combined ROI representations or None if no masks available.
        """
        if cell_image_masks is None:
            return None

        # Stack cell and background masks
        all_masks = [cell_image_masks]
        roi_id_map = {roi_id: index for index, roi_id in enumerate(cell_ids)}
        next_index = len(cell_ids)

        # Add background masks if available (Minian is 2D only)
        if background_image_masks is not None:
            # Handle 2D (single background) vs 3D (multiple backgrounds)
            if len(background_image_masks.shape) == 2:
                # Single background: add a dimension to make it (H, W, 1)
                background_image_masks = background_image_masks[:, :, np.newaxis]

            num_backgrounds = background_image_masks.shape[2]

            # Determine background IDs matching trace naming convention
            for bg_index in range(num_backgrounds):
                bg_id = f"background-{bg_index}"
                roi_id_map[bg_id] = next_index
                next_index += 1

            all_masks.append(background_image_masks)

        # Concatenate all masks along the last axis to get (H, W, total_rois)
        # TODO: Optimize memory usage by implementing lazy loading for Zarr arrays.
        # Currently loads entire array into memory (~8.5 MB for 608x608x3 dataset, not so bad).
        # Could use lazy wrapper similar to DatasetView (used by CNMF-E, EXTRACT, NWB)
        # Let's re-assess if this becomes an issue in the future
        combined_masks = np.concatenate(all_masks, axis=2) if len(all_masks) > 1 else all_masks[0]

        return _ROIMasks(
            data=combined_masks,
            mask_tpe="nwb-image_mask",
            field_of_view_shape=self.get_frame_shape(),  # (H, W) for 2D
            roi_id_map=roi_id_map,
        )

    def _read_zarr_group(self, zarr_group: str):
        """Read the zarr group.

        Parameters
        ----------
        zarr_group : str
            The zarr group path to read

        Returns
        -------
        zarr.Group or None
            The zarr group object specified by self.folder_path and zarr_group,
            or None if the group is not found.
        """
        if zarr_group not in zarr.open(self.folder_path, mode="r"):
            warnings.warn(f"Group '{zarr_group}' not found in the Zarr store.", UserWarning)
            return None
        else:
            return zarr.open(str(self.folder_path) + f"/{zarr_group}", "r")

    def _read_roi_image_mask_from_zarr(self):
        """Read the image masks from the zarr output.

        Returns
        -------
        image_masks: numpy.ndarray
            The image masks for each ROI.
        """
        dataset = self._read_zarr_group("/A.zarr")
        if dataset is None or "A" not in dataset:
            raise ValueError("No image masks found in A.zarr dataset.")
        else:
            # Transpose to (height, width, weight) format because A.zarr is stored as (weight, height, width)
            return np.transpose(dataset["A"], (1, 2, 0))

    def _read_background_image_mask_from_zarr(self):
        """Read the background image masks (b) from the zarr output.

        b.zarr structure is expected to be like:
        ├── b.zarr
        │   ├── animal () <U7
        │   ├── b (608, 608) float64
        │   ├── height (608,) int64
        │   ├── session () <U14
        │   ├── session_id () <U9
        │   ├── unit_id () int64
        │   └── width (608,) in

        Returns
        -------
        image_masks: numpy.ndarray
            The image masks for each background components.
        """
        dataset = self._read_zarr_group("/b.zarr")
        if dataset is None or "b" not in dataset:
            raise ValueError("No background image masks found in b.zarr dataset.")
        else:
            return np.expand_dims(dataset["b"], axis=2)

    def _read_trace_from_zarr_field(self, field: str):
        """Read the traces specified by the field from the zarr object.

        Parameters
        ----------
        field: str
            The field to read from the zarr object.

        Returns
        -------
        trace: numpy.ndarray
            The traces specified by the field.
        """
        dataset = self._read_zarr_group(f"/{field}.zarr")

        if dataset is None or field not in dataset:
            return None
        elif dataset[field].ndim == 2:
            return np.transpose(dataset[field])
        elif dataset[field].ndim == 1:
            return np.expand_dims(dataset[field], axis=1)

    def get_native_timestamps(self, start_sample: int | None = None, end_sample: int | None = None) -> np.ndarray:
        """
        Get the native format timestamps from the CSV file.

        Parameters
        ----------
        start_sample : int, optional
            The starting sample index. If None, starts from the beginning.
        end_sample : int, optional
            The ending sample index. If None, goes to the end.

        Returns
        -------
        np.ndarray
            The native timestamps in seconds.
        """
        csv_file = self._timestamps_path
        df = pd.read_csv(csv_file)
        frame_indexes = self._read_zarr_group("/C.zarr/frame")
        filtered_df = df[df["Frame Number"].isin(frame_indexes)]

        native_timestamps = filtered_df["Time Stamp (ms)"].to_numpy() * 1e-3

        # Set defaults
        if start_sample is None:
            start_sample = 0
        if end_sample is None:
            end_sample = self.get_num_samples()

        return native_timestamps[start_sample:end_sample]

    def sample_indices_to_time(self, sample_indices: FloatType | np.ndarray) -> FloatType | np.ndarray:
        """Convert user-inputted sample indices to times with units of seconds.

        Parameters
        ----------
        sample_indices: int or array-like
            The sample indices to be converted to times.

        Returns
        -------
        times: float or array-like
            The corresponding times in seconds.
        """
        # Default implementation
        if self._times is None:
            self._times = self.get_native_timestamps()

        return self._times[sample_indices]

    def has_time_vector(self) -> bool:
        if self._times is None:
            self._times = self.get_native_timestamps()
        return True  # The MinianSegmentationExtractor always has a time vector from the timestamps CSV.

    def get_frame_shape(self) -> tuple[int, int]:
        """Get the frame shape (height, width) from the zarr dataset.

        Returns
        -------
        tuple[int, int]
            The frame shape as (height, width).

        Raises
        ------
        ValueError
            If the A.zarr dataset or height/width dimensions are not found.
        """
        # First try to get frame shape from the zarr dataset
        dataset = self._read_zarr_group("/A.zarr")
        if dataset is None or "height" not in dataset or "width" not in dataset:
            # Fallback: try to infer from roi_masks if available
            if self._roi_masks is not None:
                return self._roi_masks.field_of_view_shape
            else:
                raise ValueError(
                    "Cannot determine frame shape: height/width dimensions not found, "
                    "and no ROI masks are available to infer frame shape."
                )

        height = dataset["height"].shape[0]
        width = dataset["width"].shape[0]
        return (height, width)

    def get_roi_ids(self) -> list:
        """Get a list of ROI ids from the A.zarr dataset.

        Returns
        -------
        roi_ids: list
            List of ROI ids.

        Raises
        ------
        Warnings
            If the A.zarr dataset is not found or does not contain 'unit_id'.
        """
        dataset = self._read_zarr_group("/A.zarr")
        if dataset is None or "unit_id" not in dataset:
            warnings.warn("No ROI ids found in A.zarr dataset. A range of indexes will be used as ROI ids", UserWarning)
            return super().get_roi_ids()  # Fallback to default implementation
        return list(dataset["unit_id"])

    def get_accepted_list(self) -> list:
        """Get a list of accepted ROI ids.

        Returns
        -------
        accepted_list: list
            List of accepted ROI ids.
        """
        return self.get_roi_ids()

    def get_rejected_list(self) -> list:
        """Get a list of rejected ROI ids.

        Returns
        -------
        rejected_list: list
            List of rejected ROI ids.
        """
        return list()

    def get_images_dict(self) -> dict:
        """Get images as a dictionary with key as the name of the ROIResponseSeries.

        Returns
        -------
        _roi_image_dict: dict
            dictionary with key, values representing different types of Images used in segmentation:
                Mean, Correlation image, Maximum projection
        """
        return dict(self._summary_images)

    def get_sampling_frequency(self) -> float | None:
        """Get the sampling frequency in Hz.

        Returns
        -------
        sampling_frequency: float
            Sampling frequency of the recording in Hz.

        Raises
        ------
        ValueError
            If no sampling frequency is available and timestamps cannot be used to derive it.
        """
        if self._sampling_frequency is not None:
            return float(self._sampling_frequency)

        # If no sampling frequency provided, try to derive from timestamps
        if self._timestamps_path.exists():
            timestamps = self.get_native_timestamps()
            if len(timestamps) > 1:
                # Calculate average sampling frequency from time differences
                diff_ts = np.diff(timestamps)
                rounded_diff_ts = diff_ts.round(decimals=6)
                uniq_diff_ts = np.unique(rounded_diff_ts)
                derived_freq = 1.0 / diff_ts[0] if len(uniq_diff_ts) == 1 else None
                if derived_freq is None:
                    warnings.warn(
                        f"Timestamps are irregularly spaced; cannot derive a sampling frequency from timestamps in {self._timestamps_path}. Will return None.",
                        UserWarning,
                    )
                    return None
                else:
                    return float(derived_freq)

    def _get_session_id(self) -> str:
        """Get the session id from the A.zarr group.

        Returns
        -------
        session_id: str
            The session id.

        Raises
        ------
        Warnings
            If the A.zarr dataset is not found or does not contain 'session_id'.
        """
        dataset = self._read_zarr_group("/A.zarr")
        if dataset is None or "session_id" not in dataset:
            warnings.warn(
                "No 'session_id' found in A.zarr dataset. Returning an empty string for 'session_id'.", UserWarning
            )
            return ""
        return dataset["session_id"][()]

    def _get_subject_id(self) -> str:
        """Get the subject id from the A.zarr group.

        Returns
        -------
        subject_id: str
            The subject id.session_id

        Raises
        ------
        Warnings
            If the A.zarr dataset is not found or does not contain 'animal'.
        """
        dataset = self._read_zarr_group("/A.zarr")
        if dataset is None or "animal" not in dataset:
            warnings.warn(
                "No 'animal' found in A.zarr dataset. Returning an empty string for 'subject_id'.", UserWarning
            )
            return ""
        return dataset["animal"][()]
